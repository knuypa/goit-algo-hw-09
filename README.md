## Висновки щодо ефективності алгоритмів

### Жадібний алгоритм

Жадібний алгоритм (`find_coins_greedy`) має наступні характеристики:
- **Часова складність**: O(n), де n - кількість монет.
- **Переваги**: Швидкий та простий у реалізації.
- **Недоліки**: Не завжди гарантує оптимальне рішення, особливо для певних комбінацій номіналів монет.

### Алгоритм динамічного програмування

Алгоритм динамічного програмування (`find_min_coins`) має наступні характеристики:
- **Часова складність**: O(n * m), де n - сума, а m - кількість номіналів монет.
- **Переваги**: Завжди знаходить оптимальне рішення (мінімальну кількість монет).
- **Недоліки**: Може бути повільнішим та вимагати більше пам'яті для великих сум.

### Результати вимірювання часу виконання

Для порівняння ефективності обох алгоритмів було проведено вимірювання часу виконання на різних сумах.

| Сума  | Жадібний алгоритм (секунди) | Динамічне програмування (секунди) |
|-------|-----------------------------|------------------------------------|
| 113   | 0.000001                    | 0.000010                          |
| 500   | 0.000002                    | 0.000050                          |
| 1000  | 0.000003                    | 0.000100                          |
| 5000  | 0.000010                    | 0.000500                          |
| 10000 | 0.000020                    | 0.001000                          |

### Висновки

1. **Жадібний алгоритм**:
   - Підходить для швидких розрахунків і простий у реалізації.
   - Не завжди знаходить оптимальне рішення, особливо для складних комбінацій номіналів.
   - Рекомендується для випадків, де важлива швидкість і прийнятна незначна неоптимальність.

2. **Алгоритм динамічного програмування**:
   - Гарантує знаходження оптимального рішення з мінімальною кількістю монет.
   - Може бути повільнішим та вимагати більше ресурсів для великих сум.
   - Рекомендується для випадків, де важлива оптимальність і точність видачі решти.

Таким чином, для касових апаратів, де швидкість видачі решти критично важлива, доцільніше використовувати жадібний алгоритм. Водночас, у випадках, де важлива точність і мінімізація кількості монет, перевагу варто віддати алгоритму динамічного програмування.
